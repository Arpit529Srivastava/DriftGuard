name: PR Checks

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  # Automated PR labeling and assignment
  pr-automation:
    name: PR Automation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Auto-assign PR
        uses: actions/github-script@v7
        with:
          script: |
            // Auto-assign the PR to code owners
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              assignees: ['Arpit529Srivastava']
            });

      - name: Auto-label PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Get changed files
            const changedFiles = context.payload.pull_request.files.map(file => file.filename);
            
            // Define label rules based on file patterns
            const labelRules = [
              { pattern: /\.go$/, label: 'go' },
              { pattern: /\.py$/, label: 'python' },
              { pattern: /\.(js|jsx|ts|tsx)$/, label: 'frontend' },
              { pattern: /\.(yaml|yml)$/, label: 'infrastructure' },
              { pattern: /Dockerfile/, label: 'docker' },
              { pattern: /\.md$/, label: 'documentation' },
              { pattern: /\.github\/workflows/, label: 'ci-cd' },
              { pattern: /deploy\//, label: 'deployment' },
              { pattern: /ai\//, label: 'ai-ml' },
              { pattern: /web\//, label: 'frontend' },
              { pattern: /cmd\//, label: 'backend' },
              { pattern: /internal\//, label: 'backend' },
              { pattern: /pkg\//, label: 'backend' }
            ];
            
            // Determine labels to add
            const labelsToAdd = new Set();
            
            for (const file of changedFiles) {
              for (const rule of labelRules) {
                if (rule.pattern.test(file)) {
                  labelsToAdd.add(rule.label);
                }
              }
            }
            
            // Add size label based on PR size
            const additions = context.payload.pull_request.additions;
            const deletions = context.payload.pull_request.deletions;
            const totalChanges = additions + deletions;
            
            if (totalChanges <= 10) {
              labelsToAdd.add('size/XS');
            } else if (totalChanges <= 30) {
              labelsToAdd.add('size/S');
            } else if (totalChanges <= 100) {
              labelsToAdd.add('size/M');
            } else if (totalChanges <= 500) {
              labelsToAdd.add('size/L');
            } else {
              labelsToAdd.add('size/XL');
            }
            
            // Add labels
            if (labelsToAdd.size > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: Array.from(labelsToAdd)
              });
            }

  # Check PR description and template
  pr-template-check:
    name: PR Template Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check PR description
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const description = pr.body || '';
            
            // Check if description is too short
            if (description.length < 50) {
              core.setFailed('PR description is too short. Please provide a detailed description of your changes.');
            }
            
            // Check for required sections
            const requiredSections = ['## Description', '## Type of Change', '## Testing'];
            const missingSections = requiredSections.filter(section => !description.includes(section));
            
            if (missingSections.length > 0) {
              core.setFailed(`PR description is missing required sections: ${missingSections.join(', ')}`);
            }
            
            console.log('PR description check passed');

  # Check for breaking changes
  breaking-changes-check:
    name: Breaking Changes Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for breaking changes
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const description = pr.body || '';
            const title = pr.title || '';
            
            // Check if PR is marked as breaking change
            const isBreakingChange = description.includes('[x] Breaking change') || 
                                   title.includes('[BREAKING]') ||
                                   title.includes('breaking');
            
            if (isBreakingChange) {
              // Add breaking change label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['breaking-change']
              });
              
              // Check if breaking changes are properly documented
              if (!description.includes('## Breaking Changes')) {
                core.setFailed('Breaking changes must be documented in the PR description under "## Breaking Changes" section');
              }
            }

  # Check commit message format
  commit-message-check:
    name: Commit Message Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check commit messages
        uses: actions/github-script@v7
        with:
          script: |
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const conventionalCommitPattern = /^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .+/;
            
            for (const commit of commits) {
              const message = commit.commit.message;
              if (!conventionalCommitPattern.test(message)) {
                core.setFailed(`Commit message "${message}" does not follow conventional commit format`);
              }
            }
            
            console.log('All commit messages follow conventional commit format');

  # Check for security vulnerabilities
  security-check:
    name: Security Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Check for sensitive data
  secrets-check:
    name: Secrets Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for hardcoded secrets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Patterns for potential secrets
            const secretPatterns = [
              /password\s*=\s*['"][^'"]+['"]/i,
              /secret\s*=\s*['"][^'"]+['"]/i,
              /token\s*=\s*['"][^'"]+['"]/i,
              /key\s*=\s*['"][^'"]+['"]/i,
              /api_key\s*=\s*['"][^'"]+['"]/i,
              /private_key\s*=\s*['"][^'"]+['"]/i
            ];
            
            function checkFile(filePath) {
              try {
                const content = fs.readFileSync(filePath, 'utf8');
                for (const pattern of secretPatterns) {
                  if (pattern.test(content)) {
                    core.warning(`Potential secret found in ${filePath}`);
                  }
                }
              } catch (error) {
                // File might be binary or not readable
              }
            }
            
            function walkDir(dir) {
              const files = fs.readdirSync(dir);
              for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
                  walkDir(filePath);
                } else if (stat.isFile() && /\.(go|py|js|ts|yaml|yml|json|env|toml)$/.test(file)) {
                  checkFile(filePath);
                }
              }
            }
            
            walkDir('.');
            console.log('Secrets check completed');

  # Check for license compliance
  license-check:
    name: License Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check license file
        run: |
          if [ ! -f "LICENSE" ] && [ ! -f "LICENSE.txt" ] && [ ! -f "LICENSE.md" ]; then
            echo "No LICENSE file found"
            exit 1
          fi
          echo "License file found"

  # Check for documentation updates
  docs-check:
    name: Documentation Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for documentation updates
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const codeFiles = files.filter(file => 
              file.filename.endsWith('.go') || 
              file.filename.endsWith('.py') || 
              file.filename.endsWith('.js') || 
              file.filename.endsWith('.ts')
            );
            
            const docFiles = files.filter(file => 
              file.filename.endsWith('.md') || 
              file.filename.includes('docs/')
            );
            
            // If there are code changes but no documentation changes, add a comment
            if (codeFiles.length > 0 && docFiles.length === 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: '⚠️ This PR includes code changes but no documentation updates. Please consider updating relevant documentation if needed.'
              });
            }

  # Check for test coverage
  test-coverage-check:
    name: Test Coverage Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for test files
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const codeFiles = files.filter(file => 
              file.filename.endsWith('.go') || 
              file.filename.endsWith('.py') || 
              file.filename.endsWith('.js') || 
              file.filename.endsWith('.ts')
            );
            
            const testFiles = files.filter(file => 
              file.filename.includes('_test.go') || 
              file.filename.includes('test_') || 
              file.filename.includes('.test.') ||
              file.filename.includes('__tests__')
            );
            
            // If there are code changes but no test changes, add a comment
            if (codeFiles.length > 0 && testFiles.length === 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: '⚠️ This PR includes code changes but no test updates. Please consider adding or updating tests for your changes.'
              });
            } 